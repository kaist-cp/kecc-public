searchState.loadedDescShard("lang_c", 0, "C language parser and abstract syntax tree\nAbstract syntax tree\nPreprocess and parse C source file into an abstract syntax …\nConvert byte offsets into line numbers\nDebug printer for abstract syntax tree\nSource text location tracking\nRecursive abstract syntax tree traversal\nUnnamed declarator\n<code>&amp;operand</code>\nAlignment of a type\nAlignment of a type\nAlignment specifier\n<code>… []</code>\nArray part of a declarator\nSize of an array in a declaration\nVendor specific inline assembly extensions\nAssembler name for an object\nInline assembler\n<code>lhs = rhs</code>\n<code>lhs &amp;= rhs</code>\n<code>lhs |= rhs</code>\n<code>lhs ^= rhs</code>\n<code>lhs /= rhs</code>\n<code>lhs -= rhs</code>\n<code>lhs %= rhs</code>\n<code>lhs *= rhs</code>\n<code>lhs += rhs</code>\n<code>lhs &lt;&lt;= rhs</code>\n<code>lhs &gt;&gt;= rhs</code>\n<code>_Atomic(typename)</code>\n<code>_Atomic</code>\nAttributes\nAttributes\n<code>auto</code>\nPlatform availability attribute\nPlatform availability\nPlatfrom availability attribute clause\nPlatfrom version inside availability attribute\nGNU extension\nAll operators with two operands\nBinary operators\nBinary operators\n<code>lhs &amp; rhs</code>\n<code>lhs | rhs</code>\n<code>lhs ^ rhs</code>\n<code>^ qualifiers …</code>\nElement of a compound statement\n<code>_Bool</code>\nFunction call expression\nFunction call expression\nCase in a <code>switch</code> statement\nCase range expression\nCase with a range in a <code>switch</code> statement\nCast expression\nCast expression\n<code>char</code>\nComma operator\n<code>~operand</code>\n<code>_Complex</code>\nCompound literal\nCompound literal\nConditional operator\nConditional operator\n<code>const</code>\nConstant literals\nNumeric and character constants\n<code>_Alignas(expression)</code>\nVariable, function or type declaration\n<code>for(int a = 1; …)</code>\nCommon part of a declaration\nSingle item in a declaration\nNested declarator\nName of a declarator\nDefault case in a <code>switch</code> statement\nModifies declarator type\nSingle element of an designation in an initializer\n<code>expression.identifier</code>\n<code>lhs / rhs</code>\nDo statement\nno suffix\n<code>double</code>\nWhether function signature ends with a <code>...</code>\n<code>for(; …)</code>\n<code>enum identifier { … }</code>\nEnumeration type specifier\nSingle constant inside a <code>enum</code> definition\n<code>lhs == rhs</code>\nExpressions\n<code>for(a = 1; …)</code>\nExtended vendor-specific syntax that does not fit elsewhere\nVendor-specific declaration extensions that can be mixed …\n<code>extern</code>\nTop-level elements of a C program\nFloating point number literal\n<code>f</code> suffix\n<code>float</code>\nFloating point number base\nFloating point literal format specified by the suffix\nFloating point number suffix\nFirst element of a <code>for</code> statement\nFor statement\n<code>… ( parameters )</code>\nFunction parameter part of a declarator\nFunction definition\nFunction specifier\nSingle element of a generic selection expression\nType match case in a generic selection expression\nGeneric selection expression\nGeneric selection\nSingle input or output operand specifier for GNU extended …\nBasic asm statement with just source code\nExtended statement that has access to C variables\nExtended statement that has access to C variables\n<code>lhs &gt; rhs</code>\n<code>lhs &gt;= rhs</code>\nVariable, function and other names that are not type names\nIdentifier\nNamed declarator\nGoto label\nIf statement\n<code>lhs[rhs]</code>\nArray element\n<code>expression-&gt;identifier</code>\n<code>*operand</code>\nDefines a single name in a declaration\nValue that is assigned immediately in a declaration\nInitializes one field or array element in a initializer …\n<code>inline</code>\nno <code>l</code> or <code>ll</code>\n<code>int</code>\nInteger number literal\nBase of the integer literal\nSize part of a integer literal suffix\nSuffix of an integer literal\n<code>… ( identifiers )</code>\nStatement labels for <code>goto</code> and <code>switch</code>\nLabeled statement\n<code>lhs &lt; rhs</code>\n<code>lhs &lt;= rhs</code>\n<code>lhs &amp;&amp; rhs</code>\n<code>lhs || rhs</code>\n<code>l</code>\n<code>long</code>\n<code>l</code> suffix\n<code>ll</code>\nStructure and union members\nStruct or union member\nStructure and union members\nStruct or union member access\n<code>-operand</code>\n<code>lhs - rhs</code>\n<code>lhs % rhs</code>\n<code>lhs * rhs</code>\n<code>!operand</code>\n‘_Nonnull’ (Clang extension)\n<code>_Noreturn</code>\n<code>lhs != rhs</code>\n‘_Null_unspecified’ (Clang extension)\n‘_Nullable’ (Clang extension)\nOffset designator in a <code>offsetof</code> macro expansion\nSingle element of an offset designator\nMember offset expression\nMember offset expression\nComplete parameter declaration in a function prototype or …\n<code>+operand</code>\n<code>lhs + rhs</code>\n<code>* qualifiers …</code>\nList of qualifiers that can follow a <code>*</code> in a declaration\n<code>operand--</code>\n<code>operand++</code>\n<code>--operand</code>\n<code>++operand</code>\nRange of array elements\nRange array designator in an initializer\n<code>register</code>\n<code>restrict</code>\n<code>lhs &lt;&lt; rhs</code>\n<code>lhs &gt;&gt; rhs</code>\n<code>short</code>\n<code>signed</code>\nSizeOf a type\nSize of a type\nSize of an unary expression\nSize of a unary expression\nType and qualifiers for a struct declaration\nElement of a function body\nStatement expression\n<code>static</code>\nStatic assertion\n<code>for(_StaticAssert(…); …)</code>\n<code>[static 10]</code>\nStorage class\nString literal\nString literal\n<code>struct identifier { … }</code>\nSingle declaration in a struct or a union\nField declarator for a struct or a union\nStruct field declaration\nThe only difference between a <code>struct</code> and a <code>union</code>\nStructure or union type specifier\nSwitch statement\nFloating point types with guaranteed width and …\nFloating point formats\nFloating point type with guaranteed width and format\nISO/IEC TS 18661-2:2015 <code>df</code>, <code>dd</code>, <code>dl</code> suffixes\n<code>_Thread_local</code>\nEntire C source file after preprocessing\n<code>_Alignas(typename)</code>\nReferences to types outside of declarations\nType of an expression or type\nSpecifies type of another type or expression\nType qualifier\nType specifier\n<code>typedef</code>\nName of a previously defined type\nAll operators with one operand\nUnary operators\nUnary operator expression\n<code>[]</code>\n<code>unsigned</code>\nVariable argument list access\nVariable argument list access\n<code>[10]</code>\n<code>[*]</code>\n<code>void</code>\n<code>volatile</code>\nWhile statement\nList of structure of union members, when present.\nK&amp;R style parameter type definitions (C11 6.9.1 §6)\nContains function name and parameter list\nContains pointer, array and function declarator elements\nVendor-specific extensions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInteger literal is an imaginary part of a complex number\nInteger literal is an imaginary part of a complex number\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat is being declared\nMinimum size of the integer literal\nReturn type of the function, possibly mixed with other …\nBody of the function.\nInteger literal has unsigned type\nStandard C11 with Clang extensions\nParser configuration\nError type returned from <code>parse</code>\nC language flavors\nStandard C11 with GNU extensions\nResult of a successful parse\nStrict standard C11\nSyntax error during parsing\nColumn number in the preprocessed source\nCommand used to invoke C preprocessor\nOptions to pass to the preprocessor program\nTokens expected at the error location\nLanguage flavor to parse\nQuoted and comma-separated list of expected tokens\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLine number in the preprocessed source\nByte position in the preproccessed source\nParse a C file\nPre-processed source text\nPre-processed source text\nRoot of the abstract syntax tree\nUse <code>clang</code> as a pre-processor and enable Clang extensions\nUse <code>gcc</code> as a pre-processor and enable gcc extensions\nReturns the argument unchanged.\nFind file name and line number that correspond to an …\nCalls <code>U::from(self)</code>.\nPrinting visitor\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAssociate a span with an arbitrary type\nByte offset of a node start and end positions in the input …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if span is undefined\nCreate new node\nCreate a new undefined span that is equal to any other span\nCreate a new span for a specific location")