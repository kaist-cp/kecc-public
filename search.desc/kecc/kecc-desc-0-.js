searchState.loadedDescShard("kecc", 0, "KECC: KAIST Educational C Compiler.\nTrait to check if a type can be translated.\nThe error type.\nA C file going through IR generation.\nEssentially the same as <code>PartialEq</code>.\nC file Parser.\nSimplifies block exits by propagating constants.\nRemoves empty blocks\nMerges two blocks if a block is pointed to only by another\nRetains only those blocks that are reachable from the init.\nThe type to translate to.\nTranslates <code>S</code> to <code>Translate::Target</code>.\nAssert that the type can be translated.\nDeclarations made in the C file (e.g, global variables and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe intermediate representation.\nHomework: IR Generation\nSee <code>PartialEq::eq</code>.\nOk or exiting the process.\nOk or exiting the process.\nSome or exiting the process.\nSome or exiting the process.\nTemporary counter for anonymous structs. One should not …\nStructs defined in the C file,\nTests asmgen.\nTests end-to-end translation.\nTests irgen.\nTests irparse.\nTests optimizations.\nTests write_c.\nTranslate <code>source</code> to <code>Self::Target</code>.\nType definitions made in the C file (e.g, typedef my_type …\nWrite <code>t</code> to <code>write</code>.\n.align integer\nE.g., a0\nAn assembly file.\n.byte value\ncall offset\nThe assembler implements several directives that control …\nfcvt.s.d or fcvt.d.s\nfcvt.l(u).s or fcvt.l(u).d fcvt.w(u).s or fcvt.w(u).d\nfcvt.s.l(u) or fcvt.d.l(u) fcvt.s.w(u) or fcvt.d.w(u)\nfmv.s rd, rs or fmv.d rd, rs\nfmv.x.w or fmv.x.w\nfmv.w.x or fmv.d.x\nfneg.s rd, rs or fneg.d rd, rs\n.globl symbol\n.half value\n%hi\nRISC-V Base Instructions Set.\nj offset\njalr rs\njr rs\nla rd, symbol\n<code>Label</code> is used as branch, unconditional jump targets and …\nli rd, immediate\n%lo\nmv rd, rs\nneg(w) rd, rs\nThe assembler implements several convenience …\n.quad value\nIf the enum variant contains <code>is_signed : bool</code>, it …\nABI name for RISC-V integer and floating-point register.\n%hi(symbol) or %lo(symbol)\nThe relocation function creates synthesize operand values …\nret\nE.g., s0\n.section section_type\nseqz rd, rs\nsext.w rd, rs\nsnez rd, rs\nE.g., t0\n.type symbol, symbol_type\n.word value\n.zero bytes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHeaders provide size, offset, type, alignment and flag …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse Error\nC file Parser.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRegisters holding block arguments.\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\n<code>GetElementPtr</code> is inspired from <code>getelementptr</code> instruction …\nTODO(document)\nTODO(document)\nRegisters holding pointers to local allocations.\nFor uncommon error\nTODO(document)\nTODO(document)\nRegisters holding the results of instructions.\nTODO(document)\nTODO(document)\nA value, used for “simple copy”.\nFormat <code>lang_c::ast::{Binary,Unary}Operations</code> into KECC-IR.\nMemory allocations for local variables.  The allocation is …\nThe initial block id.\nFirst instruction in the block.\nBasic blocks.\nTODO(document)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFirst instruction in the function.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if type is conflicting for pre-declared one\nGenerate <code>Dtype</code> based on parameter declaration.\nDerive a data type containing scalar type from specifiers.\nDerive a data type from <code>type_name</code>.\nCreate an appropriate declaration according to <code>dtype</code>.\nVisualize IR.\nChange operations into a String.\n<code>value</code> may be <code>f32</code>, but it is possible to consider it as <code>f64</code>.\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\n<code>value</code> may be <code>f32</code>, but it is possible to consider it as <code>f64</code>.\nTODO(document)\nTODO(document)\nTODO(document) A boolean value cannot be signed.\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nFor uncommon error\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nApply <code>PointerQualifier</code> to <code>BaseDtype</code>.\nApply <code>StorageClassSpecifier</code> to <code>BaseDtype</code>.\nApply <code>Typequalifier</code> to <code>BaseDtype</code>.\nApply <code>TypeSpecifier</code> to <code>BaseDtype</code>.\nTODO(document)\nTODO(document)\nTODO(document)\nReturns the argument unchanged.\nTODO(document)\nCalls <code>U::from(self)</code>.\nCheck if <code>Dtype</code> is constant. if it is constant, the …\nTODO(document)\nIf the struct type has a definition, it is saved to the …\nTODO(document)\nDerive a data type from declaration specifiers.\nDerive a data type and its name from the struct …\nTODO(document)\nGenerates <code>Dtype</code> based on declarator and <code>self</code> which has a …\nGenerate <code>Dtype</code> based on declarator and <code>self</code> which has a …\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nTODO(document)\nBidirectional map between the name of a global variable …\nMap the memory box id to the name of a global variable\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMaps each global variable to a pointer value.\nCreate a bi-directional mapping between <code>var</code> and <code>bid</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap the name of a global variable to the memory box id\n<code>value</code> may be <code>f32</code>, but it is possible to consider it as <code>f64</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFirst instruction in the block.\nFirst instruction in the function.\nStorage for instructions up to the insertion of a block\nA C file going through IR generation.\nError format when a compiler error happens.\nA C function being translated.\nFor uncommon error\nAdds a possibly existing declaration.\nAdd a declaration. It can be either a struct, typedef, or …\nAdd a function definition.\nAllocate a new block id.\nAllocate a new temporary id.\nlocal allocations.\nThe block id of the current context.\ncurrent block id. <code>blocks</code> must have an entry for all ids …\ninitial block id for the function, typically 0.\nMap from block id to basic blocks\nDeclarations made in the C file (e.g, global variables and …\nEnter a scope and create a new symbol table entry, i.e, we …\nExit a scope and remove the a oldest symbol table entry. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new allocation with type given by <code>alloc</code>.\nInsert a new block <code>context</code> with exit instruction <code>exit</code>.\nInserts <code>var</code> with <code>value</code> to the current symbol table.\nCurrent instructions of the block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new context with block number bid\narguments represented as initial phinodes. Order must be …\nreturn type of the function.\nTemporary counter for anonymous structs. One should not …\nUsable structs\nStructs defined in the C file,\nCurrent symbol table. The initial symbol table has the …\ncurrent temporary id. Used to create temporary names in …\nTranslate initial parameter declarations of the functions …\nTransalte a C statement <code>stmt</code> under the current block …\nUsable definitions\nType definitions made in the C file (e.g, typedef my_type …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUtilities for implementing optimizations.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSimplifies block exits by propagating constants.\nRemoves empty blocks\nMerges two blocks if a block is pointed to only by another\nRetains only those blocks that are reachable from the init.\nTests asmgen.\nTests end-to-end translation.\nTests irgen.\nTests irparse.\nTests optimizations.\nTests write_c.\nTrait to check if a type can be translated.\nThe error type.\nEssentially the same as <code>PartialEq</code>.\nThe type to translate to.\nTranslates <code>S</code> to <code>Translate::Target</code>.\nAssert that the type can be translated.\nSee <code>PartialEq::eq</code>.\nTranslate <code>source</code> to <code>Self::Target</code>.\nA trait for writing a type to a <code>Write</code> stream with a new …\nEssentially the same as <code>ToString</code>.\nWrite <code>t</code> to <code>write</code>.\nWrite <code>indent</code> number of double spaces to <code>write</code>.\nWrite <code>self</code> to <code>write</code>, starting at <code>indent</code> number of double …\nSee <code>ToString::to_string</code>.")